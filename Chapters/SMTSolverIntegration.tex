\chapter{SMT Solver Integration in Elixir}
\label{cap:smtSolverIntegration}

\textcolor{red}{TODO}

\section{SMT-LIB interpreter bindings}

\textcolor{red}{TODO}

Explain why we have developed this in the way that we have done it.

Mention relevant facts of the development process and implementation details.

Present the resulting tool, the \gls{dsl} and an example.

\section{The L0 language}

Show the formalization of L0, a simple language in top of where 
the \gls{ir} is defined.

Present also an implementation draft in terms of our \gls{dsl}.

\subsection{Notation}

We assume that $\mathbb{F}$ is the set of many-sorted logic formulae involving
equality, uninterpreted function symbols and arithmetic. We use $\varphi$, 
$\psi$, etc. to denote elements from this set.

We assume a set $\Sigma^{0}$ of uninterpreted function symbols.

We assume a set $\mathbb{T}$ of terms in many-sorted logic, generated by the 
following grammar:

\[
\mathbb{T} \ni t ::= n \mid x \mid f(t_1, \ldots, t_m)
\]

where $n$ is a number, $x$ is a variable, and $f \in \Sigma^0$ is a function 
symbol of arity $m$.

\subsection{Syntax}

We assume the following syntax for the lowest level language, which corresponds
to Elixir expressions that send SMT-LIB statements to the solver:

\[
\begin{array}{rcll}
\Exp{0} \ni \epsilon & ::= & \skipE & \{ \textrm{do nothing} \}\\
& | & \failE & \{ \textrm{fail signal} \}\\
& | & \epsilon_1;\epsilon_2 & \{ \textrm{sequential evaluation} \}\\
& | & \localE~\epsilon & \{ \textrm{local scoped proof state} \}\\
& | & \addE~\varphi &  \{ \textrm{add a logic formula $\varphi \in \mathbb{F}$ to the state} \}\\
& | & \declareConstE{x} &  \{ \textrm{declare constant of type $\Term$} \}\\
& | & \whenUnsatE{\epsilon_1}{\epsilon_2}{\epsilon_3} &  \{ \textrm{unsatisfiability test} \}\\
\end{array}
\]

where $\varphi \in \mathbb{F}$ denotes a formula of arithmetic logic with 
equality and uninterpreted function symbols. 

If $I = [i_1, \ldots, i_n]$ is a sequence of elements, we use the notation
$\overline{\epsilon_i}^{i \in I}$ to denote the sequential composition 
$\epsilon_{i_1};\dots;\epsilon_{i_n}$.

\subsection{Semantics}

Let $V$ be a set of variable names, $\mathbb{F}(V)$ the subset of $\mathbb{F}$ 
with free variables in $V$, and a predicate \unsat{\_} which, given a set of 
formulas from $\mathbb{F}$, determines whether they are unsatisfiable or not. 
We define the big step operational semantics of L0 expressions as the smallest 
relation $\BS{\epsilon}{X}{\Phi}{(X', \Phi')}$ between $\Exp{0} \times 
\mathcal{P}(V) \times \mathcal{P}({\mathbb{F}(V)})$ and 
$\mathcal{P}(V) \times \mathcal{P}({\mathbb{F}(V)})$ that satisfies the following 
rules:

\bigskip

\begin{prooftree}
  \AxiomC{ }
  \UnaryInfC{$\BS{\skipE}{X}{\Phi}{(X, \Phi)}$}
\end{prooftree}

\begin{center}
\begin{minipage}[t]{0.45\textwidth}
  \begin{prooftree}
    \AxiomC{$\varphi \in \mathbb{F}(X)$}
    \UnaryInfC{$\BS{\addE~\varphi}{X}{\Phi}{(X, \Phi \cup \{\varphi\})}$}
  \end{prooftree}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
  \begin{prooftree}
    \AxiomC{$x \notin X$}
    \UnaryInfC{$\BS{\declareConstE{x}}{X}{\Phi}{(X \cup \{x\}, \Phi)}$}
  \end{prooftree}
\end{minipage}
\end{center}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon_1}{X}{\Phi}{(X', \Phi')}$}
  \AxiomC{$\BS{\epsilon_2}{X'}{\Phi'}{(X'', \Phi'')}$}
  \BinaryInfC{$\BS{\epsilon_1;\epsilon_2}{X}{\Phi}{(X'', \Phi'')}$}
\end{prooftree}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon}{X}{\Phi}{(X', \Phi')}$}
  \UnaryInfC{$\BS{\localE~\epsilon}{X}{\Phi}{(X, \Phi)}$}
\end{prooftree}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon_1}{X}{\Phi}{(X', \Phi')}$}
  \AxiomC{$\unsat{\Phi'}$}
  \AxiomC{$\BS{\epsilon_2}{X}{\Phi}{(X'', \Phi'')}$}
  \TrinaryInfC{$\BS{\whenUnsatE{\epsilon_1}{\epsilon_2}{\epsilon_3}}{X}{\Phi}{(X'', \Phi'')}$}
\end{prooftree}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon_1}{X}{\Phi}{(X', \Phi')}$}
  \AxiomC{$\neg\unsat{\Phi'}$}
  \AxiomC{$\BS{\epsilon_3}{X}{\Phi}{(X'', \Phi'')}$}
  \TrinaryInfC{$\BS{\whenUnsatE{\epsilon_1}{\epsilon_2}{\epsilon_3}}{X}{\Phi}{(X'', \Phi'')}$}
\end{prooftree}

\bigskip

The absence of rules for the $\failE$ expression is intentional, because we want 
any reachable $\failE$ to prevent the whole expression for evaluating. This also happens
if the same variable is declared twice or if a formula with undeclared
variables is being added.

\subsection{Implementation}

\textcolor{red}{TODO}

Simple implementation using the SMT-LIB bindings for Elixir.

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmodule L0 do
  import SmtLib

  defmacro init(conn) do
    quote do
      run(unquote(conn)) do
        declare_sort Term
      end
    end
  end

  defmacro eval(_, {:skip, _, _}) do
    quote do
      nil
    end
  end

  defmacro eval(_, {:fail, _, _}) do
    quote do
      raise "Verification failed"
    end
  end

  defmacro eval(conn, {:seq, _, [e1, e2]}) do
    quote do
      conn = unquote(conn)
      eval(conn, unquote(e1))
      eval(conn, unquote(e2))
    end
  end

  defmacro eval(conn, {:local, _, [e]}) do
    quote do
      conn = unquote(conn)
      {_, :ok} = run(conn, push)
      eval(conn, unquote(e))
      {_, :ok} = run(conn, pop)
    end
  end

  defmacro eval(conn, {:add, _, [f]}) do
    quote do
      conn = unquote(conn)
      {_, :ok} = run(conn, assert(unquote(f)))
    end
  end

  defmacro eval(conn, {:declare_const, _, [x]}) do
    quote do
      conn = unquote(conn)
      {_, :ok} = run(conn, declare_const([{unquote(x), Term}]))
    end
  end

  defmacro eval(conn, {:when_unsat, _, [e1, [do: e2, else: e3]]}) do
    quote do
      conn = unquote(conn)
      {_, :ok} = run(conn, push)
      eval(conn, unquote(e1))
      {_, {:ok, result}} = run(conn, check_sat)
      {_, :ok} = run(conn, pop)

      case result do
        :unsat -> eval(conn, unquote(e2))
        _ -> eval(conn, unquote(e3))
      end
    end
  end

  defmacro eval(_, other) do
    raise "Unknown L0 expression #{Macro.to_string(other)}"
  end
end
\end{lstlisting}
