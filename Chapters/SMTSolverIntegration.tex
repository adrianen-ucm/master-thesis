\chapter{SMT Solver Integration in Elixir}
\label{cap:smtSolverIntegration}

In order to implement our system, we will require to be able to interact with an
\acrshort{smt} solver from Elixir. We have decided to use the Z3 theorem prover,
which implements SMT-LIB, and to communicate with it precisely by using this
standard.

Then, we will introduce a simple formal language whose semantics are defined in
terms of the \gls{smt} problem, and an example of its implementation in Elixir
as a result of the previous integration with the solver.

\section{SMT-LIB interpreter binding}

As we did not find any existing Elixir package that met our requirements, we
addressed the implementation of an SMT-LIB interpreter binding as an opportunity
to get started with Elixir in practice, and also with its macro system. This has
given place to a side project which consists of an Elixir \gls{dsl} to
communicate with SMT-LIB interpreters, and may be at the end provided to be
available for the Elixir community.

\subsection{Overview}
\label{integ:dslexample}

By using our solver \gls{dsl}, the SMT-LIB example shown in \ref{prelim:smtlib}
can be written in Elixir as follows:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
import SmtLib

with_local_conn do
  declare_const x: Int,
                y: Int

  assert !((:x + 3 <= :y + 3) ~> (:x <= :y))
  check_sat |> IO.inspect()
end
\end{lstlisting}

which prints to \verb|{:ok, :unsat}|, proving that $$x + 3
\leq y + 3 \Rightarrow x \leq y$$

We provide a \verb|run| macro that evaluates the given \gls{dsl} block by
communicating with a solver. This communication can be reused, customized and
configured, but if none is provided as in the example, it uses a default fresh
one that communicates with Z3 through Elixir ports.

On the one hand, the expressions corresponding to logical formulas include
support for variables, uninterpreted function application, quantifiers, and
built-in operators and logic connectives such as \verb|+|, \verb|!| and
\verb|&&|.

On the other hand, it currently supports a subset of SMT-LIB commands that is
shown in the following section, but it is almost trivial to add support for new
ones, being the biggest deal to parse its response if it has a specific one. 

\subsection{Implementation}

As explained in \ref{prelim:typespecs}, we will use Elixir type specifications
as a guide to explain our implementation in a simplified form.

First, we have defined \verb|type|s to represent SMT-LIB commands and responses
from the subset that we have shown in \ref{prelim:smtlib}:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@type command_t ::
  {:assert, term_t}
  | :check_sat
  | {:push, numeral_t}
  | {:pop, numeral_t}
  | {:declare_const, symbol_t, sort_t}
  | {:declare_sort, symbol_t, numeral_t}
  | {:declare_fun, symbol_t, [sort_t], sort_t}

@type general_response_t ::
  :success
  | :unsupported
  | {:error, string_t}
  | {:specific_success_response, specific_success_response_t}
\end{lstlisting}

where other involved types like \verb|numeral_t| and \verb|sort_t| are defined 
similarly, many of them as an alias to built-in Elixir value types.

Then, we have implemented a function that, given a subset of the Elixir AST
(i.e. our \gls{dsl}), transforms it into a list of SMT-LIB commands:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec ast_to_commands(ast) :: [command_t]
\end{lstlisting}

Its implementation defines cases for each possible term and subterms, like the
following for the \verb|declare-const| command:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec ast_to_command(SmtLib.ast) :: command_t
def ast_to_command({:declare_const, _, [{v, s}]}) do
  {:declare_const, symbol(v), sort(s)}
end
\end{lstlisting}

On the one hand, once we were able to transform the \gls{dsl} into SMT-LIB
commands, we required a function to render each command into a \verb|string|
that an SMT-LIB interpreter understands:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec command_to_string(command_t) :: String.t
\end{lstlisting}

It handles compositionally the \verb|command_t| type with cases like the
following:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
{:declare_const, s1, s2} ->
  "(declare-const #{symbol(s1)} #{sort(s2)})"
\end{lstlisting}

On the other hand, in order to understand the solver responses, we have also
implemented a function that parses a received \verb|string|:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec general_response_from_string(String.t) :: 
  {:ok, general_response_t} 
  | {:error, term}
\end{lstlisting}

It has been implemented using \verb|NimbleParsec|, an Elixir package of parser
combinators, in order to delegate this task and get the reliability of a well
tested tool \citep{NimbleDocs}. Its top level parser definition is as follows:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defparsec :general_response,
  skip_blanks_and_comments()
  |> choice([
    token(success()) |> eos(),
    token(unsupported()) |> eos(),
    token(error()) |> eos(),
    token(specific_success_response()) |> eos()
  ])
\end{lstlisting}

Finally, to interact with the solver, we have defined an Elixir low level
protocol to send SMT-LIB commands and receive SMT-LIB responses in a synchronous
way:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defprotocol Connection do
  @spec send_command(t, command_t) :: 
    :ok | {:error, term}
  def send_command(connection, command)

  @spec receive_response(t) 
    :: {:ok, general_response_t} | {:error, term}
  def receive_response(connection)
end
\end{lstlisting}

We provide a default implementation to communicate with Z3 through ports and allow to
configure some of its parameters like the timeout, but other implementations
involving different solvers and communication mechanisms should also be
possible.

All of this makes possible to implement and provide the public \gls{api} of the 
package under a top level module that can be used as in \ref{integ:dslexample}.

\section{The L0 language}

This section exposes a formal language that we have called L0 and will
represent the lowest level of our verification system.

It is intended to be implemented as Elixir expressions that send SMT-LIB 
statements to an \acrshort{smt} solver and will allow us to define a
verification \gls{ir} on top of it.

\subsection{Notation}

We assume that $\mathbb{F}$ is the set of many-sorted logic formulae involving
equality, uninterpreted function symbols and arithmetic. We use $\varphi$, 
$\psi$, etc. to denote elements from this set.

Also, we assume a set $\Sigma^{0}$ of uninterpreted function symbols and a set
$\mathbb{T}$ of terms in many-sorted logic, generated by the following grammar:

\[
\mathbb{T} \ni t ::= n \mid x \mid f(t_1, \ldots, t_m)
\]

where $n$ is a number, $x$ is a variable, and $f \in \Sigma^{0}$ is a function 
symbol of arity $m$.

\subsection{Syntax}

The syntax of L0 expressions is given by the following grammar:

\[
\begin{array}{rcll}
\Exp{0} \ni \epsilon & ::= & \skipE & \{ \textrm{do nothing} \}\\
& | & \failE & \{ \textrm{fail signal} \}\\
& | & \epsilon_1;\epsilon_2 & \{ \textrm{sequential evaluation} \}\\
& | & \localE~\epsilon & \{ \textrm{local scoped proof state} \}\\
& | & \addE~\varphi &  \{ \textrm{add a logic formula $\varphi \in \mathbb{F}$ to the state} \}\\
& | & \declareConstE{x} &  \{ \textrm{declare constant of type $\Term$} \}\\
& | & \whenUnsatE{\epsilon_1}{\epsilon_2}{\epsilon_3} &  \{ \textrm{unsatisfiability conditional} \}\\
\end{array}
\]

If $I = [i_1, \ldots, i_n]$ is a sequence of elements, we use the notation
$\overline{\epsilon_i}^{i \in I}$ to denote the sequential composition 
$\epsilon_{i_1};\dots;\epsilon_{i_n}$.

\subsection{Semantics}

Let $V$ be a set of variable names, $\mathbb{F}(V)$ the subset of $\mathbb{F}$ 
with free variables in $V$, and a predicate \unsat{\_} which, given a set of 
formulas from $\mathbb{F}$, determines whether they are unsatisfiable or not. 
We define the big step operational semantics of L0 expressions as the smallest 
relation $\BS{\epsilon}{X}{\Phi}{(X', \Phi')}$ between $\Exp{0} \times 
\mathcal{P}(V) \times \mathcal{P}({\mathbb{F}(V)})$ and 
$\mathcal{P}(V) \times \mathcal{P}({\mathbb{F}(V)})$ that satisfies the following 
rules:

\bigskip

\begin{prooftree}
  \AxiomC{ }
  \UnaryInfC{$\BS{\skipE}{X}{\Phi}{(X, \Phi)}$}
\end{prooftree}

\begin{center}
\begin{minipage}[t]{0.45\textwidth}
  \begin{prooftree}
    \AxiomC{$\varphi \in \mathbb{F}(X)$}
    \UnaryInfC{$\BS{\addE~\varphi}{X}{\Phi}{(X, \Phi \cup \{\varphi\})}$}
  \end{prooftree}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
  \begin{prooftree}
    \AxiomC{$x \notin X$}
    \UnaryInfC{$\BS{\declareConstE{x}}{X}{\Phi}{(X \cup \{x\}, \Phi)}$}
  \end{prooftree}
\end{minipage}
\end{center}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon_1}{X}{\Phi}{(X', \Phi')}$}
  \AxiomC{$\BS{\epsilon_2}{X'}{\Phi'}{(X'', \Phi'')}$}
  \BinaryInfC{$\BS{\epsilon_1;\epsilon_2}{X}{\Phi}{(X'', \Phi'')}$}
\end{prooftree}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon}{X}{\Phi}{(X', \Phi')}$}
  \UnaryInfC{$\BS{\localE~\epsilon}{X}{\Phi}{(X, \Phi)}$}
\end{prooftree}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon_1}{X}{\Phi}{(X', \Phi')}$}
  \AxiomC{$\unsat{\Phi'}$}
  \AxiomC{$\BS{\epsilon_2}{X}{\Phi}{(X'', \Phi'')}$}
  \TrinaryInfC{$\BS{\whenUnsatE{\epsilon_1}{\epsilon_2}{\epsilon_3}}{X}{\Phi}{(X'', \Phi'')}$}
\end{prooftree}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon_1}{X}{\Phi}{(X', \Phi')}$}
  \AxiomC{$\neg\unsat{\Phi'}$}
  \AxiomC{$\BS{\epsilon_3}{X}{\Phi}{(X'', \Phi'')}$}
  \TrinaryInfC{$\BS{\whenUnsatE{\epsilon_1}{\epsilon_2}{\epsilon_3}}{X}{\Phi}{(X'', \Phi'')}$}
\end{prooftree}

\bigskip

The absence of rules for the $\failE$ expression is intentional, because we
want any reachable $\failE$ to prevent the whole expression for evaluating.
We have also required this to happen if the same variable is declared twice
or if a formula with undeclared variables is being added.

\subsection{Implementation}
\label{integ:l0implementation}

It is difficult to justify the compliance of an implementation of L0 with its
formal semantics due to the undecidability of the \gls{smt} problem in the 
general case. In practice, this task will be delegated to an \acrshort{smt} 
solver as if it were a black box that can solve the problem.

We can implement a simple Elixir \gls{dsl} for the L0 language in terms of our
SMT-LIB binding for Elixir. The \verb|fail| expression raises an exception:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(_, {:fail, _, _}) do
  quote do
    raise "Verification failed"
  end
end
\end{lstlisting}

The \verb|local| expression surrounds the evaluation in between \verb|pop| and
\verb|push| SMT-LIB commands:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(conn, {:local, _, [e]}) do
  quote do
    conn = unquote(conn)
    :ok = push conn
    eval conn, unquote(e)
    :ok = pop conn
  end
end
\end{lstlisting}

The \verb|add| expression corresponds to an \verb|assert| in SMT-LIB:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(conn, {:add, _, [f]}) do
  quote do
    conn = unquote(conn)
    :ok = assert conn, unquote(f)
  end
end
\end{lstlisting}

Similarly, the \verb|declare-const| expression corresponds to a
\verb|declare_const| in SMT-LIB:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(conn, {:declare_const, _, [x]}) do
  quote do
    conn = unquote(conn)
    :ok = declare_const conn, [{unquote(x), Term}]
  end
end
\end{lstlisting}

The \verb|when-unsat| expression implementation is slightly longer:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(
  conn, 
  {:when_unsat, _, [e1, [do: e2, else: e3]]}
) do
  quote do
    conn = unquote(conn)
    :ok = push conn
    eval conn, unquote(e1)
    {:ok, result} = check_sat conn
    :ok = pop conn

    case result do
      :unsat -> eval conn, unquote(e2)
      _ -> eval conn, unquote(e3)
    end
  end
end
\end{lstlisting}

Finally, instead of implementing a \verb|seq| expression, we can reuse Elixir
blocks by handling several cases:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(
  conn, 
  do: {:__block__, [], []}
) when is_list(es) do
  nil
end

defmacro eval(
  conn, 
  do: {:__block__, [], [e | es]}
) when is_list(es) do
  quote do
    conn = unquote(conn)
    eval conn, unquote(e)
    eval conn, unquote({:__block__, [], [es]})
  end
end

defmacro eval(conn, do: e) do
  quote do
    conn = unquote(conn)
    eval conn, unquote(e)
  end
end
\end{lstlisting}

We can also include a general case that raises an exception if the provided
Elixir \gls{ast} does not correspond to our language:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(_, other) do
  raise "Unknown expression #{Macro.to_string(other)}"
end
\end{lstlisting}

Assuming the defined macros to be in scope, and a \verb|conn| variable that
represents a fresh connection with an \acrshort{smt} solver and has the
\verb|Term| sort already defined, this would be a simple example of its usage:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
eval conn do
  declare_const :x

  # Replacing `!=' by `==' leads to 
  # a verification exception
  when_unsat add :x != :x do
    skip
  else
    fail
  end
end
\end{lstlisting}
