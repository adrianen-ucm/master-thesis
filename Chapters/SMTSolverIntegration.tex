\chapter{SMT Solver Integration in Elixir}
\label{cap:smtSolverIntegration}

In order to implement our system, we will require to be able to interact with
an \acrshort{smt} solver from Elixir. We have decided to use the Z3 theorem
prover, which implements SMT-LIB, and to communicate with it precisely by using
this standard.

Then, we will introduce a simple formal language whose semantics are defined
in terms of the \gls{smt} problem, and an example of its implementation in 
Elixir as a result of the previous integration with a solver.

\section{SMT-LIB interpreter binding}

Initially, we found an Elixir package that provides integration with Z3 and is
implemented using ports, but it seemed to be not so mature and maintained. It 
was also not published in Hex, the Elixir package manager, and we had no
guarantees about if it would lack some functionality that we would require at
some point.

To implement our own SMT-LIB interpreter binding was an opportunity to get
started with Elixir in practice, and also with its macro system. This has 
given place to a side project which consists of an Elixir \gls{dsl} to
communicate with SMT-LIB interpreters, and may be at the end provided to 
be available for the Elixir community.

\subsection{Example}
\label{integ:dslexample}

\textcolor{red}{TODO}: overview of the resulting tool, its \gls{dsl} and an example.

\subsection{Implementation}

Although Elixir is dynamically typed, it has a system to annotate the intended
types for functions and a tool to perform a static analysis on them. We will
use these specifications together with function identifiers to outline the ideas
behind our implementation.

First, we define \verb|type|s to represent SMT-LIB commands and responses
from the subset that we have exposed in \ref{prelim:smtlib}:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@type command_t ::
  {:assert, term_t}
  | :check_sat
  | {:push, numeral_t}
  | {:pop, numeral_t}
  | {:declare_const, symbol_t, sort_t}
  | {:declare_sort, symbol_t, numeral_t}
  | {:declare_fun, symbol_t, [sort_t], sort_t}

@type general_response_t ::
  :success
  | :unsupported
  | {:error, string_t}
  | {:specific_success_response, specific_success_response_t}
\end{lstlisting}

where other involved types like \verb|numeral_t| and \verb|sort_t| are defined 
similarly, many of them as an alias to built-in Elixir value types.

Then, we implement a function \verb|commands/1| that, given a subset of the 
Elixir AST (i.e. our \gls{dsl}), transforms it into a list of SMT-LIB commands:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec commands(ast) :: [command_t]
\end{lstlisting}
  
Its implementation defines cases for each possible term and subterms, 
like the following for the \verb|declare-const| command:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec command(ast) :: command_t
def command({:declare_const, _, [{v, s}]}) do
  {:declare_const, symbol(v), sort(s)}
end
\end{lstlisting}

\textcolor{red}{TODO}: explain the DSL and distinguish from function names by modules

Once we are able to transform the \gls{dsl} into SMT-LIB commands, we require 
a function to render each command into a \verb|string| that an SMT-LIB
interpreter understands:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec command(command_t) :: String.t
\end{lstlisting}

It handles compositionally the \verb|command_t| type with cases like the
following:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
{:declare_const, s1, s2} ->
  "(declare-const #{symbol(s1)} #{sort(s2)})"
\end{lstlisting}

Communication with ports, implementation for Z3 but it can be other

Finally, in order to understand the solver responses, we have also implemented
a failable function that parses the received \verb|string|:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec general_response(String.t) :: 
  {:ok, general_response_t} 
  | {:error, term}
\end{lstlisting}

It has been implemented using \verb|nimble|, an Elixir package of parser
combinators, in order to delegate this task and get the reliability of a well
tested tool [referenciar]. Its top level parser definition is as follows:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defparsec :general_response,
  skip_blanks_and_comments()
  |> choice([
    token(success()) |> eos(),
    token(unsupported()) |> eos(),
    token(error()) |> eos(),
    token(specific_success_response()) |> eos()
  ])
\end{lstlisting}

We expose then the public \gls{api} of the package under a top level module
that can be used as in \ref{integ:dslexample}.

\section{The L0 language}

This section exposes a formal language that we have called L0 and will
represent the lowest level of our verification system.

It is intended to be implemented as Elixir expressions that send SMT-LIB 
statements to an \acrshort{smt} solver and will allow us to define a
verification \gls{ir} on top of it.

\subsection{Notation}

We assume that $\mathbb{F}$ is the set of many-sorted logic formulae involving
equality, uninterpreted function symbols and arithmetic. We use $\varphi$, 
$\psi$, etc. to denote elements from this set.

Also, we assume a set $\Sigma^{0}$ of uninterpreted function symbols and a set
$\mathbb{T}$ of terms in many-sorted logic, generated by the following grammar:

\[
\mathbb{T} \ni t ::= n \mid x \mid f(t_1, \ldots, t_m)
\]

where $n$ is a number, $x$ is a variable, and $f \in \Sigma^{0}$ is a function 
symbol of arity $m$.

\subsection{Syntax}

The syntax of L0 expressions is given by the following grammar:

\[
\begin{array}{rcll}
\Exp{0} \ni \epsilon & ::= & \skipE & \{ \textrm{do nothing} \}\\
& | & \failE & \{ \textrm{fail signal} \}\\
& | & \epsilon_1;\epsilon_2 & \{ \textrm{sequential evaluation} \}\\
& | & \localE~\epsilon & \{ \textrm{local scoped proof state} \}\\
& | & \addE~\varphi &  \{ \textrm{add a logic formula $\varphi \in \mathbb{F}$ to the state} \}\\
& | & \declareConstE{x} &  \{ \textrm{declare constant of type $\Term$} \}\\
& | & \whenUnsatE{\epsilon_1}{\epsilon_2}{\epsilon_3} &  \{ \textrm{unsatisfiability conditional} \}\\
\end{array}
\]

If $I = [i_1, \ldots, i_n]$ is a sequence of elements, we use the notation
$\overline{\epsilon_i}^{i \in I}$ to denote the sequential composition 
$\epsilon_{i_1};\dots;\epsilon_{i_n}$.

\subsection{Semantics}

Let $V$ be a set of variable names, $\mathbb{F}(V)$ the subset of $\mathbb{F}$ 
with free variables in $V$, and a predicate \unsat{\_} which, given a set of 
formulas from $\mathbb{F}$, determines whether they are unsatisfiable or not. 
We define the big step operational semantics of L0 expressions as the smallest 
relation $\BS{\epsilon}{X}{\Phi}{(X', \Phi')}$ between $\Exp{0} \times 
\mathcal{P}(V) \times \mathcal{P}({\mathbb{F}(V)})$ and 
$\mathcal{P}(V) \times \mathcal{P}({\mathbb{F}(V)})$ that satisfies the following 
rules:

\bigskip

\begin{prooftree}
  \AxiomC{ }
  \UnaryInfC{$\BS{\skipE}{X}{\Phi}{(X, \Phi)}$}
\end{prooftree}

\begin{center}
\begin{minipage}[t]{0.45\textwidth}
  \begin{prooftree}
    \AxiomC{$\varphi \in \mathbb{F}(X)$}
    \UnaryInfC{$\BS{\addE~\varphi}{X}{\Phi}{(X, \Phi \cup \{\varphi\})}$}
  \end{prooftree}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
  \begin{prooftree}
    \AxiomC{$x \notin X$}
    \UnaryInfC{$\BS{\declareConstE{x}}{X}{\Phi}{(X \cup \{x\}, \Phi)}$}
  \end{prooftree}
\end{minipage}
\end{center}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon_1}{X}{\Phi}{(X', \Phi')}$}
  \AxiomC{$\BS{\epsilon_2}{X'}{\Phi'}{(X'', \Phi'')}$}
  \BinaryInfC{$\BS{\epsilon_1;\epsilon_2}{X}{\Phi}{(X'', \Phi'')}$}
\end{prooftree}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon}{X}{\Phi}{(X', \Phi')}$}
  \UnaryInfC{$\BS{\localE~\epsilon}{X}{\Phi}{(X, \Phi)}$}
\end{prooftree}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon_1}{X}{\Phi}{(X', \Phi')}$}
  \AxiomC{$\unsat{\Phi'}$}
  \AxiomC{$\BS{\epsilon_2}{X}{\Phi}{(X'', \Phi'')}$}
  \TrinaryInfC{$\BS{\whenUnsatE{\epsilon_1}{\epsilon_2}{\epsilon_3}}{X}{\Phi}{(X'', \Phi'')}$}
\end{prooftree}

\bigskip

\begin{prooftree}
  \AxiomC{$\BS{\epsilon_1}{X}{\Phi}{(X', \Phi')}$}
  \AxiomC{$\neg\unsat{\Phi'}$}
  \AxiomC{$\BS{\epsilon_3}{X}{\Phi}{(X'', \Phi'')}$}
  \TrinaryInfC{$\BS{\whenUnsatE{\epsilon_1}{\epsilon_2}{\epsilon_3}}{X}{\Phi}{(X'', \Phi'')}$}
\end{prooftree}

\bigskip

The absence of rules for the $\failE$ expression is intentional, because we
want any reachable $\failE$ to prevent the whole expression for evaluating.
We have also required this to happen if the same variable is declared twice
or if a formula with undeclared variables is being added.

\subsection{Implementation}

It is difficult to justify the compliance of an implementation of L0 with its
formal semantics due to the undecidability of the \gls{smt} problem in the 
general case. In practice, this task will be delegated to an \acrshort{smt} 
solver as if it were a black box that can solve the problem.

We can implement a simple Elixir \gls{dsl} for the L0 language in terms of our
SMT-LIB binding for Elixir. The \verb|fail| expression raises an exception:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(_, {:fail, _, _}) do
  quote do
    raise "Verification failed"
  end
end
\end{lstlisting}

The \verb|local| expression surrounds the evaluation in between
\verb|pop| and \verb|push| SMT-LIB commands:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(conn, {:local, _, [e]}) do
  quote do
    conn = unquote(conn)
    {_, :ok} = run(conn, push)
    eval conn, unquote(e)
    {_, :ok} = run(conn, pop)
  end
end
\end{lstlisting}

The \verb|add| expression corresponds to an \verb|assert| in 
SMT-LIB:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(conn, {:add, _, [f]}) do
  quote do
    conn = unquote(conn)
    {_, :ok} = run(conn, assert(unquote(f)))
  end
end
\end{lstlisting}

similarly, \verb|declare_const| expression corresponds to a \verb|declare_const| in 
SMT-LIB:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(conn, {:declare_const, _, [x]}) do
  quote do
    conn = unquote(conn)
    {_, :ok} = 
      run(conn, declare_const([{unquote(x), Term}]))
  end
end
\end{lstlisting}

The \verb|eval| expression implementation is slightly longer:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(
  conn, 
  {:when_unsat, _, [e1, [do: e2, else: e3]]}
) do
  quote do
    conn = unquote(conn)
    {_, :ok} = run(conn, push)
    eval conn, unquote(e1)
    {_, {:ok, result}} = run(conn, check_sat)
    {_, :ok} = run(conn, pop)

    case result do
      :unsat -> eval conn, unquote(e2)
      _ -> eval conn, unquote(e3)
    end
  end
end
\end{lstlisting}

Finally, instead of implementing a \verb|seq| expression, we can reuse 
Elixir blocks by handling several cases:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(
  conn, 
  do: {:__block__, [], es}
) when is_list(es) do
  quote do
    conn = unquote(conn)
    eval conn, unquote(es)
  end
end

defmacro eval(conn, do: e) do
  quote do
    conn = unquote(conn)
    eval conn, unquote(e)
  end
end

defmacro eval(_, []) do
  nil
end

defmacro eval(conn, [e | es]) do
  quote do
    conn = unquote(conn)
    eval conn, unquote(e)
    eval conn, unquote(es)
  end
end
\end{lstlisting}

We can also include a general case that raises an exception if 
the provided Elixir \gls{ast} does not correspond to our language:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmacro eval(_, other) do
  raise "Unknown expression #{Macro.to_string(other)}"
end
\end{lstlisting}

Assuming the defined macros to be in scope, a \verb|conn| variable that
represents a fresh connection with an \acrshort{smt} solver which
has the \verb|Term| sort already defined, this would be a simple example
of its usage:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
eval conn do
  declare_const :x

  # Replacing `!=' by `=' leads to 
  # a verification exception
  when_unsat add :x != :x do
    skip
  else
    fail
  end
end
\end{lstlisting}
