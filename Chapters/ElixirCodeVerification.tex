\chapter{Elixir Code Verification}
\label{cap:elixirCodeVerification}

\chapterquote{Do not fear mistakes - there are none}{Miles Davis}

\textcolor{red}{TODO}

\section{The L2 verification language}

\textcolor{red}{TODO}

\subsection{Syntax}

Let us define the set $\Exp{2}$ of sequential Elixir expressions given by the 
following grammar:

\[
\begin{array}{rcll}
\Exp{2} \ni E & ::= & e & \{ \textrm{L1 expression} \} \\
& | & P = E & \{ \textrm{pattern matching} \} \\
& | & E_1; E_2 & \{ \textrm{sequence} \} \\
& | & \caseE~E~\doW & \{ \textrm{case distinction} \} \\
& & \quad P_1~\whenE~f_1 \rightarrow E_1 \\
& & \quad \vdots\\
& & \quad P_n~\whenE~f_n \rightarrow E_n \\
& & \Wend \\
& | & \ghostE~\doW~S~\Wend & \{ \textrm{L1 ghost statement} \} \\
\end{array}
\]

Here $P$ denotes a pattern from a set $\Pat$ of patterns, defined by the 
following grammar:

\[
\Pat \ni P ::= c \mid x \mid [\:] \mid [P_1 \mid P_2] \mid \{ P_1, \ldots, P_n \}
\]

Note that the guard expressions $f_1, \ldots, f_n$ correspond to L1 expressions,
due to their restricted nature.

\subsection{Translation into L1}

In the following, given a set $A$, we use the notation $[A]$ to denote the set
of sequences of elements in $A$. If $x_1, \ldots, x_n$ we use the notation 
$[x_1, \ldots, x_n]$ to denote such a sequence. We also use a list comprehension
notation that is similar to the one in Haskell language. For example, $[(i, j)
\mid i \leftarrow [1, 2], j \leftarrow [3, 4, 5]]$.

Let us define a function: $\trEXP{\_} : \Exp{2} \rightarrow [\Stm \times
\Exp{1}]$ that, given an expression $E$ in the source language, generates a
sequence of pairs $(S, e)$ where $S$ is the L1 statement that models the
semantics of $E$, and $e$ is a L1 expression that represents the result to which
$E$ is evaluated.

We need an auxiliary function $\trMatch{\_}{\_} : \Exp{1} \times \Pat
\rightarrow \Exp{1}$ that, given an L1 expression $e$ and a pattern $P$, returns
another L1 expression that is a $\mathit{boolean}$ term and is evaluated to
$\true$ if and only if $e$ matches $P$. Its definition is as follows:

\[
\begin{array}{l}
\trMatch{e}{c} = e~\texttt{===}~{c}\\
\trMatch{e}{[\:]} = e~\texttt{===}~{[\:]} \\
\trMatch{e}{x} = \mathit{true}\\
\trMatch{e}{\{P_1,\ldots,P_n\}}\\
\qquad = \textit{is-tuple}(e)~\mathbf{and}~\textit{tuple-size}(e)~\texttt{===}~n~\mathbf{and}~(\mathbf{and}_{i=1}^n~\trMatch{\textit{elem}(e, i)}{P_i})\\
\trMatch{e}{[P_1\mid P_2]}\\
\qquad = \textit{is-nelist}(e)~\mathbf{and}~\trMatch{\textit{hd}(e)}{P_1}~\mathbf{and}~\trMatch{\textit{tl}(e)}{P_2}
\end{array}
\]

Also, $\mathit{vars}(P)$ is a function to denote the $L1$ variable expressions
that appear in a pattern $P$.

L2 expressions that are contained within the syntax of L1 are translated as they
are, but we generate an assertion to check if the singleton tuple which contains
that expression is a tuple. This will force to introduce the expression in the
generated L1 statements to be verified. Otherwise, bad formed expressions at the
top level whose translation yields to verification failures may be ignored
during the L2 translation (e.g. \verb|true + 2|):

\[
\trEXP{e} = [(\assertE~\textit{is\mbox{-}tuple}(\{e\}), e)]
\]

Another approach would be to extend the L1 syntax with a new statement that just
checks an L1 expression.

A $\ghostE$ expression is translated into an arbitrary $L1$ expression, for
example the empty list, and the provided $L1$ statement as its meaning:

\[
\trEXP{\ghostE~\doW~S~\Wend} = [(S, [])]
\]

Expressions of the form $P = E$ are translated into assertions that check
whether the result of evaluating E matches the pattern $P$, and then assume the
equality between $P$ and $E$.

\[
\begin{array}{l}
\trEXP{P = E} = [(S_1;S_1',e_1), \dots, (S_n;S_n', e_n)] \\
\qquad 
\begin{array}{ll}
\textbf{where} & [(S_1,e_1),\dots,(S_n, e_n)] = \trEXP{E} \\
& \{y_1, \ldots, y_m\} = \mathit{vars}(P) \\
& \forall i \in \{1..n\}: S_i' = \left(
\begin{array}{l}
\assertE~\trMatch{e_i}{P};\\
\havocE~y_1;\\
\vdots\\
\havocE~y_m;\\
\assumeE~e_i ~\texttt{===}~ P\\
\end{array}
\right)
\end{array}
\end{array}
\]

In order to translate a sequence of expressions $E_1;E_2$ we have to append 
every statement generated from the translation of $E_2$ to every statement 
generated from the translation of $E_1$. We must also deal carefully with
$\ghostE$ expressions because, as its translation also returns an L1 expression,
it must be skipped in order to avoid altering the semantics of a block.

This will be its translation when the last expression is a $\ghostE$ one, taking
into account that \verb|;| is associative:

\[
\begin{array}{l}
\trEXP{E;\ghostE~\doW~S~\Wend} = [(S_i;S,e_i) \mid i \leftarrow [1..n]] \\
\qquad 
\begin{array}{ll}
\textbf{where} & [(S_1,e_1),\dots,(S_n, e_n)] = \trEXP{E} \\
\end{array}
\end{array}
\]

And this will be the general case when the previous one does not apply (i.e.
$E_2$ is not a sequence ending in a $\ghostE$):

\[
\begin{array}{l}
\trEXP{E_1;E_2} = [(S_i;S_j',e'_j) \mid i \leftarrow [1..n], j \leftarrow [1..m]] \\
\qquad 
\begin{array}{ll}
\textbf{where} & [(S_1,e_1),\dots,(S_n, e_n)] = \trEXP{E_1} \\
& [(S_1',e'_1),\dots,(S_m', e'_m)] = \trEXP{E_2} \\
\end{array}
\end{array}
\]

The translation of $\caseE$ expressions is more complex:

\[
\begin{array}{l}
\trEXP{\caseE~E~\doW~\overline{P_i~\whenE~f_i \rightarrow E_i}^n~\Wend}\\
\qquad = \left[ \begin{array}{l}
(S_j;\\
\assertE~(\andE{e_{1,j}}{f_1})~\textbf{or}~\cdots~\textbf{or}~(\andE{e_{n,j}}{f_n}); \\
\assumeE~(\textbf{not}~(e_{1,j}~\textbf{and}~f_1))~\textbf{and}~\cdots~\textbf{and}~(\textbf{not}~(e_{i-1,j}~\textbf{and}~f_{i-1})); \\
\assumeE~e_{i,j}~\textbf{and}~f_{i};\\
\havocE~y_{i,1};\\
\vdots\\
\havocE~y_{i,t_i};\\
\assumeE~e_j~\texttt{===}~P_j; \\
S_{i,k}', e_{i,k}')
\end{array}  \middle\vert
\begin{array}{l}
j \leftarrow [1..m], \\
i \leftarrow [1..n], \\
k \leftarrow [1..s_i] \\
\end{array}
\right]\\
\begin{array}{ll}
\textbf{where} & [(S_1,e_1),\ldots,(S_m,e_m)] = \trEXP{E} \\
& \forall i \in \{1..n\}: [(S'_{i,1},e'_{i,1}),\ldots,(S'_{i,s_i},e'_{i,s_i})] = \trEXP{E_i} \\
& \forall i \in \{1..n\}, j \in \{1..m\}: e_{i,j} = \trMatch{e_j}{P_i} \\
& \forall i \in \{1..n\}, \{y_{i,1}, \ldots, y_{i,t_i}\} = \mathit{vars}(P_i) \\
\end{array}
\end{array}
\]

It can be described as, for each translation of $E$, for each branch and for 
each translation of the resulting expression of that branch:

\begin{enumerate}
  \item Check that at least one pattern and guard of holds.
  \item Assume that no previous pattern and guard holds, and that the current one does.
  \item Declare the involved variables for the pattern matching.
  \item Assume that the pattern does match.
\end{enumerate}

This models appropriately the short-circuit semantics of the \verb|case|
construct because, if some branch will never be evaluated, assuming its pattern
and guard will make the hypothesis state inconsistent and everything would be
$\true$ after that, so it will not yield to validation failures.

\subsection{Verification process}

\textcolor{red}{TODO}

Verification process, and also the Elixir code generation (remove ghosts).

\subsection{Extended user-defined functions}

\textcolor{red}{TODO}

Allowing L2 expressions in user-defined functions.

\subsection{Termination}

\textcolor{red}{TODO}

Show our current ideas about termination using term sizes.

\section{Implementation}

\textcolor{red}{TODO}: show examples in a separate section before this one if possible. Introduce this section.

For the translation process, we implement a function that given Elixir \gls{ast}
code that corresponds to an L2 program (i.e. its \gls{dsl}), yields a list of
pairs with the expression in L1 that represents its resulting value, and an L1
statement that models its meaning:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec translate_l2_exp(L2Exp.ast) 
  :: [{L1Exp.ast, L1Stm.ast}]
\end{lstlisting}

As in the previous \gls{dsl} translations, its definition syntax matches closely
the formal version, as in this example for assignment with pattern matching:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
def translate_l2_exp({:=, _, [p, e]}) do
  for {t, sem} <- translate(e) do
    {
      t,
      quote do
        unquote(sem)
        assert unquote(translate_match(p, e))

        unquote_splicing(
          for var <- vars(p) do
            quote do
              havoc unquote(var)
            end
          end
        )

        assume unquote(t) === unquote(p)
      end
    }
  end
end
\end{lstlisting}

where we also have implemented an auxiliary function to obtain the variables of
a pattern, as L1 variable expressions:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec vars(Pat.ast) :: MapSet.t(L1Exp.ast)
\end{lstlisting}

and a function to perform the pattern matching translation:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec translate_match(Pat.ast, L2Exp.ast) :: L1Exp.ast
\end{lstlisting}

For example, this is the case for lists:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
def translate_match({:|, _, [p1, p2]}, e) do
  tr_1 = translate_match(p1, quote(do: hd(unquote(e))))
  tr_2 = translate_match(p2, quote(do: tl(unquote(e))))

  quote(
    do:
      is_list(unquote(e)) and unquote(e) !== [] and
        unquote(tr_1) and unquote(tr_2)
  )
end
\end{lstlisting}

\textcolor{red}{TODO}: unfold if possible, and the verification process.

By using the L1 verification function from Section \ref{ir:details}, we can
define a verification function for L2 code as follows:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
@spec verify_l2(Env.t(), L2Exp.ast()) :: [term()]
def verify_l2(env, e) do
  for {_, sem} <- translate_l2_exp(e) do
    L1Stm.eval(
      env,
      quote do
        block do
          unquote(sem)
        end
      end
    )
  end
  |> List.flatten()
end
\end{lstlisting}

Note that each possible path of the translation must be verified in an
independent proof context, so one option is to wrap each one into a \verb|block|
statement.
