\chapter{Preliminaries}
\label{cap:preliminaries}

This chapter introduces some required topics and tools that are a basis to
our project.

On the one hand, Elixir is the programming language that is the verification
subject of this document and, at the same time, the one in which our
implementation has been coded.

On the other hand, our verification system relies on the \gls{smt} problem and
its encoding in SMT-LIB, a standard language and interface to interact with
theorem provers such as Z3.

\section{Elixir}

Elixir is a general-purpose programming language that runs on the Erlang
Virtual Machine, where also the Erlang programming language runs [referenciar].
Both of them share some features, like their actor-based concurrency model,
and have a native capability to interoperate. Although Elixir is younger than
Erlang, this has allowed the former to be part of an ecosystem which has been
developed across more than three decades.

We have chosen such a programming language for this research because,
first, it is a modern programming language ready to be used in the
industry [referenciar]. Second, it has the unusual property in formal 
verification to be dynamically typed, but its functional programming principles
will make it easier to reason about. Finally, its metaprogramming capabilities
will allow us to extend it according to our needs without requiring to modify
its compiler.

\subsection{General description}

In this section, we introduce the basic concepts and constructs of sequential
programming in Elixir. Our aim is to show the behavior of the language subset
that is studied later in this document for its verification, and also
its metaprogramming mechanism based on macros, on top of which our proposed
verification system has been implemented.

The following examples will be exposed in the Elixir \gls{repl}, 
called \verb|iex|, where \verb|iex>| represents its default prompt:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> "Hello world"
"Hello world"
\end{lstlisting}

\subsubsection{Value types}

As usual, one of the core value types in Elixir is the \verb|integer|, for
which arithmetic operators behave as expected:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> (2 + 2) * 5
20
iex> -1
-1
iex> 1 / 0
** (ArithmeticError)
\end{lstlisting}

The \verb|boolean| value type is also at its core, but its operators have some
worth to mention semantics when involving non-\verb|boolean| types, and also 
with respect to short-circuit evaluation:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> true and 2 # Evaluates to the second term
2
iex> 2 and true # Requires the first one to be a boolean
** (BadBooleanError)
iex> false and 1 / 0 # Does not evaluate the second term
false
\end{lstlisting}

Some built-in Elixir functions allow checking if a given value is of a given
type in terms of a \verb|boolean| result:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> is_boolean(true)
true
iex> is_boolean(2)
false
iex> is_integer(2)
true
\end{lstlisting}

Equality and comparison operators also evaluate to \verb|boolean| values and
allow mixing types:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> 2 === 2
true
iex> 2 === true
false
iex> 2 !== true
true
iex> 2 > 1
true
iex> 2 < true
true
\end{lstlisting}

\subsubsection{Collection types}

One of the simplest built-in collection types in Elixir is the inductive 
\verb|list|, which consists of nested cons cells (i.e. pairs) and can be
written in different ways:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> [] # The empty list 
[] 
iex> [3 | []] # A cons cell
[3]
iex> [1 | [2 | [3 | []]]] # Nested cons cells
[1, 2, 3]
iex> [1, 2, 3] # Syntax sugar
[1, 2, 3]
iex> [1, 2 | [3]] # Syntax mix
[1, 2, 3]
\end{lstlisting}

It is not required for the \verb|list| elements to be of the same type, and
improper lists (i.e. those that do not have an empty list as the second element
in the last cons cell [referenciar docs]) are also allowed:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> [1, 2, false]
[1, 2, false]
iex> [1 | [2 | 3]] 
[1, 2 | 3]
\end{lstlisting}

Functions in Elixir use to be referred by its name and arity. The \verb|hd/1|
and \verb|tl/1| built-in functions for lists allow to respectively obtain the
first and second components of a cons cell:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> hd([1, 2, false])
1
iex> tl([1, 2, false])
[2, false]
iex> hd([])
** (ArgumentError)
iex> tl([])
** (ArgumentError)
\end{lstlisting}

There is also a function for checking the \verb|list| type membership. Consider
the following code to apply the \verb|is_list/1| function to several provided 
lists and return the conjunction of its results:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> Enum.all?(                 # All
  [[], [1, 2], [1, 2 | false]], # of these
  &is_list/1                    # are lists
)
true
\end{lstlisting}

Another core collection type in Elixir is the \verb|tuple|, which also does not
restrict its elements to be of the same type:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> {} # The empty tuple
{}
iex> {1, false, {3, 4}, []}
{1, false, {3, 4}, []}
\end{lstlisting}

They have a size, which can be retrieved with the \verb|tuple_size/1| function,
and each \verb|tuple| component can also be retrieved with the \verb|elem/2|
function by specifying its position with a zero-based index:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> tuple_size({1, 2, 3})
3
iex> elem({1, 2, 3}, 0)
1
iex> elem({1, 2, 3}, 2)
3
iex> elem({1, 2, 3}, 3)
** (ArgumentError)
\end{lstlisting}

In this case, the \verb|tuple| type membership checking function is
\verb|is_tuple/1|.

\subsubsection{Blocks, pattern matching and control flow}

Elixir statements can be evaluated sequentially by gathering them inside a
\verb|block| delimited by a semicolon or a line break:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> 2 + 1;5 === 5;false
false # Evaluates to the last statement value
iex> (
        2 + 1
        5 === 5
        false
     )
false
\end{lstlisting}

The \verb|match| operator \verb|=| allows binding values to variable names.
Note that these bindings are not locally scoped inside blocks and, in 
contrast to Erlang, variable bindings can be overridden:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> x = 2
2
iex> y = 2
2
iex> (z = 2, 4)
4
iex> z = 2
2
\end{lstlisting}

This operator also allows performing pattern matching, which destructures 
expressions according to patterns in order to check for a given shape and 
bind subexpressions to variable names. They are particularly useful for 
dealing with collection value types:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> {x, 3} = {2, 3}
{2, 3}
iex> {x, 3} = {2, 4}
** (MatchError)
iex> [h | t = [_, 3]] = [1, 2, 3] # A nested match
[1, 2, 3]
iex> t
[2, 3]
\end{lstlisting}

Regarding control flow, although Elixir also has usual constructs such as 
\verb|if|, one of the most general ones is \verb|case|. It Evaluates to 
the first branch that matches the pattern and is compliant with a possible
guard expression, and this is the only one that is evaluated:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
iex> case {1, 2, 3} do 
        {}                           -> 1 / 0
        {1, x, 3} when is_integer(x) -> x + 1
        {1, 2, 3}                    -> false
     end
3
iex> x
** (CompileError) # The case bindings are local
iex> case 2 do 
        false -> 3 
     end 
** (CaseClauseError) # No pattern matches the expression
\end{lstlisting}

\subsubsection{Function definitions}

A named function, identified by its name and arity, can be defined inside 
\verb|modules| with different body definitions and different matching for
its arguments:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
defmodule Example do 
  def fact(0) do 
    1
  end

  def fact(n) when is_integer(n) and n > 0 do 
    n * fact(n - 1) # Recursion is allowed
  end
end
\end{lstlisting}

The rules for which one is applied are the same as in \verb|case| expressions,
so function definitions can also express control flow [referencia].

\subsection{Macros}

\textcolor{red}{TODO}

Describe, this will be our way to extend Elixir for code verification.

\subsection{Interoperability}

\textcolor{red}{TODO} for the \acrshort{smt} solver integration.

Elixir offers several ways to interoperate with processes or libraries that are
external to the Erlang Virtual Machine, apart from conventional \gls{io}. 

One of them are \gls{nif}s, which allow loading and calling libraries
implemented in other programming languages such as C. A crash in a \gls{nif}
brings the Erlang Virtual Machine down too. [referencia docs erlang]

A more safe approach is to launch an external process managed by the Erlang
Virtual Machine and communicate with it by means of message passing, which in 
Elixir is provided as a mechanism called \textit{ports}:

\begin{lstlisting}[language=elixir,numbers=none,frame=none]
port = Port.open({:spawn, "cat"}, [:binary])
iex> send(port, {self(), {:command, "hello"}})
iex> flush()
# Received from the process
{#Port<0.1444>, {:data, "hello"}} 
send(port, {self(), :close})
\end{lstlisting}

A known drawback of this is that if the Erlang Virtual Machine crashes after 
having launched a long-running process, its stdin and stdout channels
will be closed, it won't be automatically terminated. This depends on the 
behavior of the specific process when its communication channels are closed.

\section{Satisfiability Modulo Theories}

The \gls{smt} problem consists of checking whether
a given logical formula is satisfiable within a specific theory
\citep{smtLibStandard}. This allows to define theories in which the \gls{smt} problem
is decidable and, moreover, to design efficient algorithms specialized in 
solving this problem for a theory.

\textcolor{red}{TODO}

Para esto último, poner un ejemplo referenciado de una teoría con \gls{smt} decidible y algún 
algoritmo eficiente.

\subsection{SMT-LIB}
\label{prelim:smtlib}

SMT-LIB is an initiative which tries to provide a common interface to interact
with \acrshort{smt} solvers. It defines a solver-agnostic standard language
with a Lisp-like syntax to both configure a solver, manage it, encode an
\gls{smt} problem instance and query for solutions.

General description (many sorted, citado) and example, show the subset of commands that we are going to use

\textcolor{red}{TODO}

\[
\begin{array}{rcll}
\langle\textit{ command }\rangle & ::= & \texttt{( assert } \langle\textit{ term }\rangle\texttt{ ) }\\
& | & \texttt{( check-sat )}\\
& | & \texttt{( pop } \langle\textit{ numeral }\rangle \texttt{ ) }\\
& | & \texttt{( push } \langle\textit{ numeral }\rangle \texttt{ ) }\\
& | & \texttt{( declare-sort } \langle\textit{ symbol }\rangle~\langle\textit{ numeral }\rangle\texttt{ ) }\\
& | & \texttt{( declare-const } \langle\textit{ symbol }\rangle~\langle\textit{ sort }\rangle\texttt{ ) }\\
& | & \texttt{( declare-fun } \langle\textit{ symbol }\rangle \texttt{ ( }\langle\textit{ symbol }\rangle^* \texttt{ ) }\langle\textit{ sort }\rangle\texttt{ ) }\\
\end{array}
\]

\textcolor{red}{TODO}
Poner un problema sencillo de ejemplo. Separar a anexo o buscar otro mas corto?

\begin{verbatim}
; The propositional variable 'pi_j' means that the node i appears in 
; the path position j, where nodes are labeled as natural numbers 
; starting from 0.
(declare-const p0_0 Bool)
(declare-const p0_1 Bool)
(declare-const p0_2 Bool)
(declare-const p0_3 Bool)
(declare-const p1_0 Bool)
(declare-const p1_1 Bool)
(declare-const p1_2 Bool)
(declare-const p1_3 Bool)
(declare-const p2_0 Bool)
(declare-const p2_1 Bool)
(declare-const p2_2 Bool)
(declare-const p2_3 Bool)
(declare-const p3_0 Bool)
(declare-const p3_1 Bool)
(declare-const p3_2 Bool)
(declare-const p3_3 Bool)

; Every node should appear in at least one position.
(assert (or p0_0 p0_1 p0_2 p0_3))
(assert (or p1_0 p1_1 p1_2 p1_3))
(assert (or p2_0 p2_1 p2_2 p2_3))
(assert (or p3_0 p3_1 p3_2 p3_3))

; Two different nodes do not appear in the same path position.
(assert (not (and p0_0 p1_0)))
(assert (not (and p0_1 p1_1)))
(assert (not (and p0_2 p1_2)))
(assert (not (and p0_3 p1_3)))
(assert (not (and p0_0 p2_0)))
(assert (not (and p0_1 p2_1)))
(assert (not (and p0_2 p2_2)))
(assert (not (and p0_3 p2_3)))
(assert (not (and p0_0 p3_0)))
(assert (not (and p0_1 p3_1)))
(assert (not (and p0_2 p3_2)))
(assert (not (and p0_3 p3_3)))
(assert (not (and p1_0 p0_0)))
(assert (not (and p1_1 p0_1)))
(assert (not (and p1_2 p0_2)))
(assert (not (and p1_3 p0_3)))
(assert (not (and p1_0 p2_0)))
(assert (not (and p1_1 p2_1)))
(assert (not (and p1_2 p2_2)))
(assert (not (and p1_3 p2_3)))
(assert (not (and p1_0 p3_0)))
(assert (not (and p1_1 p3_1)))
(assert (not (and p1_2 p3_2)))
(assert (not (and p1_3 p3_3)))
(assert (not (and p2_0 p0_0)))
(assert (not (and p2_1 p0_1)))
(assert (not (and p2_2 p0_2)))
(assert (not (and p2_3 p0_3)))
(assert (not (and p2_0 p1_0)))
(assert (not (and p2_1 p1_1)))
(assert (not (and p2_2 p1_2)))
(assert (not (and p2_3 p1_3)))
(assert (not (and p2_0 p3_0)))
(assert (not (and p2_1 p3_1)))
(assert (not (and p2_2 p3_2)))
(assert (not (and p2_3 p3_3)))
(assert (not (and p3_0 p0_0)))
(assert (not (and p3_1 p0_1)))
(assert (not (and p3_2 p0_2)))
(assert (not (and p3_3 p0_3)))
(assert (not (and p3_0 p1_0)))
(assert (not (and p3_1 p1_1)))
(assert (not (and p3_2 p1_2)))
(assert (not (and p3_3 p1_3)))
(assert (not (and p3_0 p2_0)))
(assert (not (and p3_1 p2_1)))
(assert (not (and p3_2 p2_2)))
(assert (not (and p3_3 p2_3)))

; If two nodes are not adjacent, then they do not appear
; consecutively in the path.
(assert (=> p1_0 (not p3_1)))
(assert (=> p1_1 (not p3_2)))
(assert (=> p1_2 (not p3_3)))
(assert (=> p2_0 (not p3_1)))
(assert (=> p2_1 (not p3_2)))
(assert (=> p2_2 (not p3_3)))
(assert (=> p3_0 (not p1_1)))
(assert (=> p3_1 (not p1_2)))
(assert (=> p3_2 (not p1_3)))
(assert (=> p3_0 (not p2_1)))
(assert (=> p3_1 (not p2_2)))
(assert (=> p3_2 (not p2_3)))

(check-sat)
\end{verbatim}

\subsection{Z3}

One of the \acrshort{smt} solvers that implements the SMT-LIB standard is the
Z3 theorem prover from Microsoft Research.

\textcolor{red}{TODO}

Poner alguna referencia, enseñar su uso con -i

Decir porque lo hemos elegido y que aun así hemos intentado utilizarlo como 
interprete SMT-LIB para no depender completamente de el.

Note that there may exist subtle non-compliances when a solver implements the
SMT-LIB standard. For example, we have found that Z3 does not include the
surrounding double-quotes when it prints back the provided string literal,
which is the specified behavior in the standard.

This may add confusion because the \verb|echo| command is the only one whose
response is a string literal and, as this is not the case for Z3, there are 
corner cases in which a command response can be confused with a printed string
intended to delimit command responses, which is one of the proposed usages for
\verb|echo| in \cite{smtLibStandard}.
