\chapter{State of the Art}
\label{cap:stateOfTheArt}

\chapterquote{Don't you want to be a person who inspires others the way you were inspired by something?}{Fredrik Thordendal}

Our main goal is to provide a static verification mechanism to allow Elixir
programmers to write formal specifications and prove the conformance of their 
code in regard to these specifications. 

In this section, we will discuss the current approaches and tools for that
purpose in general, and then which are the current approaches to prove or
disprove correctness in Elixir.

\section{Program verification}

A usual approach for program verification is to transform code and
specifications into an intermediate representation, such as Boogie, and then a
theorem prover tries to prove its verification conditions, where their validity
implies the correctness under consideration \citep{Boogie2}.

In general, a theorem prover may not be able to reach a required proof, although
it may exist, and human intervention can be necessary in the form of interacting
with an interface, transforming the code to be verified or adding information to
help the prover.

\subsection{Dafny}

Dafny is a programming language that provides features for program verification
and covers several programming paradigms, such as imperative, functional and
\gls{oop} \citep{DafnyManual}.  It was created at Microsoft Research and is
currently being developed with the support of Amazon.

The following is an example to specify and verify the implementation of a
function to return the maximum of three integer numbers:

\begin{verbatim}
method max3(x: int, y: int, z: int) returns (m: int)
  ensures m == x || m == y || m == z
  ensures m >= x && m >= y && m >= y
{
  if x > y && x > z { return x; }
  if y > z { return y; }
  return z;
}
\end{verbatim}

Although the above example may seem simple, Dafny can also handle more advanced
topics such as recursion and loops by means of induction and loop invariants
respectively. Once verified, the code can be translated, erasing everything that
is related only to its verification, into other programming languages such as
C\# to be executed. 

Our project is greatly inspired by this system, although our aim is to embed
program verification features into an existing programming language instead.

\subsection{Intermediate representations}

\gls{ir}s tend to arise in compiler technologies, with goals like perform
analyses, optimizations or portability \citep{FormalizingLLVMIR}. A richer
language can be translated into a simpler or more focused one, the \gls{ir},
which can also be the translation target for other languages.

A known technology which provides a platform-independent \gls{ir} intended to be
executed in different platforms, and a toolchain to work with it, is LLVM
\citep{LLVM}.

Programming languages such as Java and Erlang also have as a compilation target
a bytecode \gls{ir} corresponding to their virtual machines, JVM and BEAM
respectively. These are also compilation targets for other programming languages
such as Kotlin and Scala for the JVM and Elixir for the BEAM virtual machine.
Also, WebAssembly is an \gls{ir} intended to be executable at native speed in
web browsers.

\subsection{Intermediate representations for verification}

For building verification tools, we are interested on \gls{ir}s that are focused
in capturing the intended verification notions and are suitable to be
transformed into an input for a theorem prover.  This last one will try to
provide a proof for the verification.

Apart from Boogie2, which is the verification \gls{ir} used in Dafny and offers 
features to model a wide range of programming paradigms, there are other ones as
\gls{viper}, that is a suite of tools which provides an intermediate
verification language with the same name and allows reasoning about the program
state using \textit{permissions} or \textit{ownership}. It allows implementing 
verification techniques for sequential and concurrent programs with mutable
state \citep{viper}.

Also, Why3 is a platform for deductive program verification that provides a
language for specification and programming, WhyML, that can be used as an
\gls{ir} for the verification of C, Java, Ada, or to obtain an automated
correct-by-construction OCaml program \citep{Why3Manual}.

Other approaches try to use logic programs as an intermediate representation 
throughout its regular compilation process, as in \cite{horn}, and other ones
put an effort into being a suitable target for modelling faithfully the
semantics of different programming languages, as in \cite{caviart}.

\subsection{SMT solvers}

At the bottom of the verification process, a theorem prover will try to obtain a
proof for some verification conditions. \acrshort{smt} solvers in particular are
gaining popularity for this task, and some current options are Z3 from
Microsoft, Z3, CVC4, MathSAT and Yices. 

There is also an international initiative, called SMT-LIB, aimed at facilitating
research and development in \gls{smt} \citep{smtLibStandard}. We will discuss 
\gls{smt}, SMT-LIB and Z3 in the Chapter \ref{cap:preliminaries} as these are
tools that are going to be used in our project.

\section{Correctness in Elixir}

The current approaches for proving or disproving the correctness of Elixir 
programs are in general inherited from Erlang, and they succeed more in 
disproving than in proving correctness.

\subsection{Dynamic}

Erlang provides several libraries for property-based testing such as \gls{triq},
\gls{proper} and Erlang QuickCheck. Many of them are offered for Elixir through
wrapper packages as \verb|ExCheck| for \gls{triq} and \verb|PropCheck| for
\gls{proper}.

There are also packages implemented completely in Elixir, as \verb|StreamData|
and \verb|TypeCheck|. This last one tries to take profit of the type
specification mechanism of Elixir in order to automatically provide data
generators.

In this case, their goal is to disprove the correctness of the program by
finding counterexamples for specified properties.

\subsection{Static}
\label{sec:static}

Elixir allows to annotate the intended types for function parameters and return
values, and a tool called \gls{dialyzer} \citep{Dialyzer} can perform static
analysis on them. A problem detected by this tool can disprove correctness, but
it does not prove correctness, which is our aim in this project.

There have been other attempts in offering tools that provide correctness proofs
for Erlang programs, as in \cite{erlangveri}.
